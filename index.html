<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/20/test/" class="article-date">
  <time datetime="2022-06-20T09:37:00.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/20/test/">test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/test/" data-id="cl4mjnbfm00007kw42036d7m0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hzw在家学习的安排" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/20/hzw%E5%9C%A8%E5%AE%B6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%89%E6%8E%92/" class="article-date">
  <time datetime="2022-06-20T05:25:21.000Z" itemprop="datePublished">2022-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/20/hzw%E5%9C%A8%E5%AE%B6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%89%E6%8E%92/">HZW在家学习的安排</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h1><p>预计2周，在期末考试周前回校。</p>
<h1 id="每日大致安排"><a href="#每日大致安排" class="headerlink" title="每日大致安排"></a>每日大致安排</h1><div class="table-container">
<table>
<thead>
<tr>
<th>时间段</th>
<th>课程数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>早上</td>
<td>5节</td>
</tr>
<tr>
<td>下午</td>
<td>5节</td>
</tr>
<tr>
<td>晚上</td>
<td>3节</td>
</tr>
<tr>
<td>总计</td>
<td>13节</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>课目</th>
<th>课程数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>语文</td>
<td>1节</td>
</tr>
<tr>
<td>数学</td>
<td>4节</td>
</tr>
<tr>
<td>英语</td>
<td>4节</td>
</tr>
<tr>
<td>文综</td>
<td>3节</td>
</tr>
<tr>
<td>自习</td>
<td>1节</td>
</tr>
</tbody>
</table>
</div>
<h1 id="每日详细安排"><a href="#每日详细安排" class="headerlink" title="每日详细安排"></a>每日详细安排</h1><div class="table-container">
<table>
<thead>
<tr>
<th>时间段</th>
<th>安排</th>
<th>学习内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>上午</td>
</tr>
<tr>
<td>07：00-07：20</td>
<td>起床洗漱</td>
</tr>
<tr>
<td>07：30-08：10</td>
<td>早自习</td>
<td>见下表</td>
</tr>
<tr>
<td>08：20-08：40</td>
<td>早饭</td>
</tr>
<tr>
<td>08：50-09：30</td>
<td>英语</td>
<td>阅读4篇</td>
</tr>
<tr>
<td>09：40-10：20</td>
<td>英语</td>
<td>阅读改错+查背陌生短语生词+精读</td>
</tr>
<tr>
<td>10：30-11：10</td>
<td>英语</td>
<td>完形2篇+查背陌生短语生词+精读</td>
</tr>
<tr>
<td>11：20-12：00</td>
<td>英语</td>
<td>复习之前的阅读完形生词短语</td>
</tr>
<tr>
<td>中午</td>
</tr>
<tr>
<td>12：00-12：20</td>
<td>午饭</td>
</tr>
<tr>
<td>12：20-13：40</td>
<td>午休</td>
<td>不允许玩手机电脑游戏机</td>
</tr>
<tr>
<td>下午</td>
</tr>
<tr>
<td>14：00-14：40</td>
<td>语文</td>
<td>古文翻译</td>
</tr>
<tr>
<td>14：50-15：30</td>
<td>数学</td>
<td>学习模式如下：</td>
</tr>
<tr>
<td>15：40-16：20</td>
<td>数学</td>
<td>1. 数学网课+教材习题+改错</td>
</tr>
<tr>
<td>16：30-17：10</td>
<td>数学</td>
<td>2. 小题狂练+改错</td>
</tr>
<tr>
<td>17：20-18：00</td>
<td>数学</td>
<td>3. 基础2000+改错</td>
</tr>
<tr>
<td>晚上</td>
</tr>
<tr>
<td>18：00-18：20</td>
<td>晚饭</td>
</tr>
<tr>
<td>18：20-19：00</td>
<td>休息</td>
<td>自行安排，但18：50前要放下手机电脑</td>
</tr>
<tr>
<td>19：00-19：40</td>
<td>文综</td>
<td>背诵基础知识</td>
</tr>
<tr>
<td>19：50-20：30</td>
<td>文综</td>
<td>补课</td>
</tr>
<tr>
<td>20：40-21：20</td>
<td>文综</td>
<td>补课</td>
</tr>
<tr>
<td>21：20-22：00</td>
<td>休息</td>
<td>自由安排</td>
</tr>
<tr>
<td>22：00-22：30</td>
<td>洗漱</td>
<td>10：30前必须睡觉</td>
</tr>
<tr>
<td>备注：周日12：00-19：00休息。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>日期</th>
<th>早自习安排</th>
</tr>
</thead>
<tbody>
<tr>
<td>周一</td>
<td>英语听力</td>
</tr>
<tr>
<td>周二</td>
<td>语文</td>
</tr>
<tr>
<td>周三</td>
<td>文综</td>
</tr>
<tr>
<td>周四</td>
<td>英语听力</td>
</tr>
<tr>
<td>周五</td>
<td>语文</td>
</tr>
<tr>
<td>周六</td>
<td>文综</td>
</tr>
<tr>
<td>周天</td>
<td>文综</td>
</tr>
</tbody>
</table>
</div>
<h1 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h1><div class="table-container">
<table>
<thead>
<tr>
<th>课目</th>
<th>目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>语文</td>
<td>古文翻译、背诵过一遍</td>
</tr>
<tr>
<td>英语</td>
<td>完成56篇阅读，28篇精读并完成文章的生词记忆，疯狂增加词汇/短语量</td>
</tr>
<tr>
<td>数学</td>
<td>必修一基础知识补牢</td>
</tr>
<tr>
<td>文综</td>
<td>根据辅导老师安排</td>
</tr>
</tbody>
</table>
</div>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>高考英语听力原题：<a target="_blank" rel="noopener" href="https://www.ximalaya.com/waiyu/40514605/">https://www.ximalaya.com/waiyu/40514605/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/20/hzw%E5%9C%A8%E5%AE%B6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%89%E6%8E%92/" data-id="cl4mjnbg000087kw4h8dh58eg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-隐私政策" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/09/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/" class="article-date">
  <time datetime="2021-10-09T13:51:59.129Z" itemprop="datePublished">2021-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="隐私政策"><a href="#隐私政策" class="headerlink" title="隐私政策"></a>隐私政策</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Pilotage软件的开发者“御风新法”重视用户的隐私。您在使用我们的服务时，我们可能会收集和使用您的相关信息。我们希望通过本《隐私政策》向您说明，在使用我们的服务时，我们如何收集、使用、储存和分享这些信息，以及我们为您提供的访问、更新、控制和保护这些信息的方式。本《隐私政策》与您所使用的Pilotage服务息息相关，希望您仔细阅读，在需要时，按照本《隐私政策》的指引，作出您认为适当的选择。本《隐私政策》中涉及的相关技术词汇，我们尽量以简明扼要的表述，并提供进一步说明的链接，以便您的理解。</p>
<p><strong>您使用或继续使用我们的服务，即意味着同意我们按照本《隐私政策》收集、使用、储存和分享您的相关信息。</strong></p>
<p>如对本《隐私政策》或相关事宜有任何问题，请通过lixieyun1123@qq.com与我们联系。</p>
<h2 id="我们可能收集的信息"><a href="#我们可能收集的信息" class="headerlink" title="我们可能收集的信息"></a>我们可能收集的信息</h2><p>我们提供服务时，可能会收集、储存和使用下列与您有关的信息。如果您不提供相关信息，可能无法注册成为我们的用户或无法享受我们提供的某些服务，或者无法达到相关服务拟达到的效果。</p>
<p><strong>您提供的信息</strong></p>
<ul>
<li>您在注册账户或使用我们的服务时，向我们提供的相关个人信息，例如电话号码、电子邮件或银行卡号等；</li>
<li>您通过我们的服务向其他方提供的共享信息，以及您使用我们的服务时所储存的信息。</li>
</ul>
<p><strong>其他方分享的您的信息</strong></p>
<ul>
<li>其他方使用我们的服务时所提供有关您的共享信息。</li>
</ul>
<p><strong>我们获取的您的信息</strong></p>
<p>您使用服务时我们可能收集如下信息：</p>
<ul>
<li><p><strong>设备ID信息</strong>。</p>
</li>
<li><p><strong>IMEI、MAC地址信息</strong></p>
</li>
</ul>
<h2 id="我们可能如何使用信息"><a href="#我们可能如何使用信息" class="headerlink" title="我们可能如何使用信息"></a>我们可能如何使用信息</h2><p>我们可能将在向您提供服务的过程之中所收集的信息用作下列用途：</p>
<ul>
<li>向您提供服务；</li>
<li>在我们提供服务时，用于身份验证、客户服务、安全防范、诈骗监测、存档和备份用途，确保我们向您提供的产品和服务的安全性；</li>
<li>帮助我们设计新服务，改善我们现有服务；</li>
<li>使我们更加了解您如何接入和使用我们的服务，从而针对性地回应您的个性化需求，例如语言设定、位置设定、个性化的帮助服务和指示，或对您和其他用户作出其他方面的回应；</li>
<li>向您提供与您更加相关的广告以替代普遍投放的广告；</li>
<li>评估我们服务中的广告和其他促销及推广活动的效果，并加以改善；</li>
<li>软件认证或管理软件升级；</li>
<li>让您参与有关我们产品和服务的调查。</li>
</ul>
<p>为了让您有更好的体验、改善我们的服务或您同意的其他用途，在符合相关法律法规的前提下，我们可能将通过某一项服务所收集的信息，以汇集信息或者个性化的方式，用于我们的其他服务。例如，在您使用我们的一项服务时所收集的信息，可能在另一服务中用于向您提供特定内容，或向您展示与您相关的、非普遍推送的信息。如果我们在相关服务中提供了相应选项，您也可以授权我们将该服务所提供和储存的信息用于我们的其他服务。</p>
<h2 id="您如何访问和控制自己的个人信息"><a href="#您如何访问和控制自己的个人信息" class="headerlink" title="您如何访问和控制自己的个人信息"></a>您如何访问和控制自己的个人信息</h2><p>我们将尽一切可能采取适当的技术手段，保证您可以访问、更新和更正自己的注册信息或使用我们的服务时提供的其他个人信息。在访问、更新、更正和删除前述信息时，我们可能会要求您进行身份验证，以保障账户安全。</p>
<h2 id="我们可能分享的信息"><a href="#我们可能分享的信息" class="headerlink" title="我们可能分享的信息"></a>我们可能分享的信息</h2><p>除以下情形外，<strong>未经您同意</strong>，我们以及我们的关联公司不会与任何第三方分享您的个人信息：</p>
<ul>
<li><p>我们以及我们的关联公司，可能将您的个人信息与我们的关联公司、合作伙伴及第三方服务供应商、承包商及代理（例如代表我们发出电子邮件或推送通知的通讯服务提供商、为我们提供位置数据的地图服务供应商）分享（他们可能并非位于您所在的法域），用作下列用途：</p>
</li>
<li><p>向您提供我们的服务；</p>
</li>
<li>实现“我们可能如何使用信息”部分所述目的；</li>
<li>履行我们在《用户协议》或本《隐私政策》中的义务和行使我们的权利；</li>
<li>理解、维护和改善我们的服务。</li>
</ul>
<p>如我们或我们的关联公司与任何上述第三方分享您的个人信息，我们将努力确保该等第三方在使用您的个人信息时遵守本《隐私政策》及我们要求其遵守的其他适当的保密和安全措施。</p>
<ul>
<li>随着我们业务的持续发展，我们以及我们的关联公司有可能进行合并、收购、资产转让或类似的交易，您的个人信息有可能作为此类交易的一部分而被转移。我们将在转移前通知您。</li>
<li><p>我们或我们的关联公司还可能为以下需要而保留、保存或披露您的个人信息：</p>
</li>
<li><p>遵守适用的法律法规；</p>
</li>
<li>遵守法院命令或其他法律程序的规定；</li>
<li>遵守相关政府机关的要求；</li>
<li>为遵守适用的法律法规、维护社会公共利益，或保护我们的客户、我们或我们的集团公司、其他用户或雇员的人身和财产安全或合法权益所合理必需的用途。</li>
</ul>
<h2 id="信息安全"><a href="#信息安全" class="headerlink" title="信息安全"></a>信息安全</h2><p>我们仅在本《隐私政策》所述目的所必需的期间和法律法规要求的时限内保留您的个人信息。</p>
<p>我们使用各种安全技术和程序，以防信息的丢失、不当使用、未经授权阅览或披露。例如，在某些服务中，我们将利用加密技术（例如SSL）来保护您提供的个人信息。但请您理解，由于技术的限制以及可能存在的各种恶意手段，在互联网行业，即便竭尽所能加强安全措施，也不可能始终保证信息百分之百的安全。您需要了解，您接入我们的服务所用的系统和通讯网络，有可能因我们可控范围外的因素而出现问题。</p>
<h2 id="您分享的信息"><a href="#您分享的信息" class="headerlink" title="您分享的信息"></a>您分享的信息</h2><p>我们的多项服务，可让您不仅与自己的社交网络，也与使用该服务的所有用户公开分享您的相关信息，例如，您在我们的服务中所上传或发布的信息（包括您公开的个人信息、您建立的名单）、您对其他人上传或发布的信息作出的回应，以及包括与这些信息有关的位置数据和日志信息。使用我们服务的其他用户也有可能分享与您有关的信息（包括位置数据和日志信息）。特别是，我们的社交媒体服务，是专为使您与世界各地的用户共享信息而设计，您可以使共享信息实时、广泛地传递。只要您不删除共享信息，有关信息会一直留存在公共领域；即使您删除共享信息，有关信息仍可能由其他用户或不受我们控制的非关联第三方独立地缓存、复制或储存，或由其他用户或该等第三方在公共领域保存。</p>
<p><strong>因此，请您谨慎考虑通过我们的服务上传、发布和交流的信息内容。</strong>在一些情况下，您可通过我们某些服务的隐私设定来控制有权浏览您共享信息的用户范围。如要求从我们的服务中删除您的相关信息，请通过该等特别服务条款提供的方式操作。</p>
<h2 id="您分享的敏感个人信息"><a href="#您分享的敏感个人信息" class="headerlink" title="您分享的敏感个人信息"></a>您分享的敏感个人信息</h2><p>某些个人信息因其特殊性可能被认为是敏感个人信息，例如您的种族、宗教、个人健康和医疗信息等。相比其他个人信息，敏感个人信息受到更加严格的保护。</p>
<p>请注意，您在使用我们的服务时所提供、上传或发布的内容和信息（例如有关您社交活动的照片等信息），可能会泄露您的敏感个人信息。您需要谨慎地考虑，是否在使用我们的服务时披露相关敏感个人信息。</p>
<p><strong>您同意按本《隐私政策》所述的目的和方式来处理您的敏感个人信息。</strong></p>
<h2 id="我们可能如何收集信息"><a href="#我们可能如何收集信息" class="headerlink" title="我们可能如何收集信息"></a>我们可能如何收集信息</h2><p>我们或我们的第三方合作伙伴，可能通过cookies和web beacon收集和使用您的信息，并将该等信息储存为日志信息。</p>
<p>我们使用自己的cookies和web beacon，目的是为您提供更个性化的用户体验和服务，并用于以下用途：</p>
<ul>
<li>记住您的身份。例如：cookies和web beacon有助于我们辨认您作为我们的注册用户的身份，或保存您向我们提供的有关您的喜好或其他信息；</li>
<li>分析您使用我们服务的情况。例如，我们可利用cookies和web beacon来了解您使用我们的服务进行什么活动，或哪些网页或服务最受您的欢迎；</li>
<li>广告优化。Cookies和web beacon有助于我们根据您的信息，向您提供与您相关的广告而非进行普遍的广告投放。</li>
</ul>
<p>我们为上述目的使用cookies和web beacon的同时，可能将通过cookies和web beacon收集的非个人身份信息，经统计加工后提供给广告商或其他合作伙伴，用于分析用户如何使用我们的服务，并用于广告服务。</p>
<p>我们的产品和服务上可能会有广告商或其他合作方放置的cookies和web beacon。这些cookies和web beacon可能会收集与您相关的非个人身份信息，以用于分析用户如何使用该等服务、向您发送您可能感兴趣的广告，或用于评估广告服务的效果。这些第三方cookies和web beacon收集和使用该等信息，不受本《隐私政策》约束，而是受相关使用者的隐私政策约束，我们不对第三方的cookies或web beacon承担责任。</p>
<p>您可以通过浏览器设置拒绝或管理cookies或web beacon。但请注意，如果停用cookies或web beacon，您有可能无法享受最佳的服务体验，某些服务也可能无法正常使用。同时，您还会收到同样数量的广告，但这些广告与您的相关性会降低。</p>
<h2 id="广告服务"><a href="#广告服务" class="headerlink" title="广告服务"></a>广告服务</h2><p>我们可能使用您的相关信息，向您提供与您更加相关的广告。</p>
<p>我们也可能使用您的信息，通过我们的服务、电子邮件或其他方式向您发送营销信息，提供或推广我们或第三方的如下商品和服务：</p>
<ul>
<li>我们的商品或服务，我们的关联公司和合作伙伴的商品或服务，包括即时通讯服务、网上媒体服务、互动娱乐服务、社交网络服务、付款服务、互联网搜索服务、位置和地图服务、应用软件和服务、数据管理软件和服务、网上广告服务、互联网金融，以及其他社交媒体、娱乐、电子商务、资讯和通讯软件或服务（统称“<strong>互联网服务</strong>”）；</li>
<li>第三方互联网服务供应商，以及与下列有关的第三方商品或服务：食物和餐饮、体育、音乐、电影、电视、现场表演及其他艺术和娱乐、书册、杂志和其他刊物、服装和配饰、珠宝、化妆品、个人健康和卫生、电子、收藏品、家用器皿、电器、家居装饰和摆设、宠物、汽车、酒店、交通和旅游、银行、保险及其他金融服务、会员积分和奖励计划，以及我们认为可能与您相关的其他商品或服务。</li>
</ul>
<p>如您不希望我们将您的个人信息用作前述广告用途，您可以通过我们在广告中提供的相关提示，或在特定服务中提供的指引，要求我们停止为上述用途使用您的个人信息。</p>
<h2 id="隐私政策的适用例外"><a href="#隐私政策的适用例外" class="headerlink" title="隐私政策的适用例外"></a>隐私政策的适用例外</h2><p>我们的服务可能包括或链接至第三方提供的社交媒体或其他服务（包括网站）。例如：</p>
<ul>
<li>您利用 “分享”键将某些内容分享到我们的服务，或您利用第三方连线服务登录我们的服务。这些功能可能会收集您的相关信息（包括您的日志信息），并可能在您的电脑装置cookies，从而正常运行上述功能；</li>
<li>我们通过广告或我们服务的其他方式向您提供链接，使您可以接入第三方的服务或网站。</li>
</ul>
<p>该等第三方社交媒体或其他服务可能由相关的第三方或我们运营。您使用该等第三方的社交媒体服务或其他服务（包括您向该等第三方提供的任何个人信息），须受该第三方的服务条款及隐私政策（而非《通用服务条款》或本《隐私政策》）约束，您需要仔细阅读其条款。<strong>本《隐私政策》仅适用于我们所收集的信息，并不适用于任何第三方提供的服务或第三方的信息使用规则，我们对任何第三方使用由您提供的信息不承担任何责任。</strong></p>
<h2 id="未成年人使用我们的服务"><a href="#未成年人使用我们的服务" class="headerlink" title="未成年人使用我们的服务"></a>未成年人使用我们的服务</h2><p>我们鼓励父母或监护人指导未满十八岁的未成年人使用我们的服务。我们建议未成年人鼓励他们的父母或监护人阅读本《隐私政策》，并建议未成年人在提交的个人信息之前寻求父母或监护人的同意和指导。</p>
<h2 id="隐私政策的适用范围"><a href="#隐私政策的适用范围" class="headerlink" title="隐私政策的适用范围"></a>隐私政策的适用范围</h2><p>除某些特定服务外，我们所有的服务均适用本《隐私政策》。这些特定服务将适用特定的隐私政策。针对某些特定服务的特定隐私政策，将更具体地说明我们在该等服务中如何使用您的信息。该特定服务的隐私政策构成本《隐私政策》的一部分。如相关特定服务的隐私政策与本《隐私政策》有不一致之处，适用该特定服务的隐私政策。</p>
<p>除本《隐私政策》另有规定外，本《隐私条款》所用词语将与《用户协议》所定义的词语具有相同的涵义。</p>
<p><strong>请您注意，本《隐私政策》不适用于以下情况：</strong></p>
<ul>
<li>通过我们的服务而接入的第三方服务（包括任何第三方网站）收集的信息；</li>
<li>通过在我们服务中进行广告服务的其他公司或机构所收集的信息。</li>
</ul>
<h2 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h2><p>我们可能适时修订本《隐私政策》的条款，该等修订构成本《隐私政策》的一部分。<strong>如该等修订造成您在本《隐私政策》下权利的实质减少，我们将在修订生效前通过在主页上显著位置提示或向您发送电子邮件或以其他方式通知您。在该种情况下，若您继续使用我们的服务，即表示同意受经修订的本《隐私政策》的约束。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/09/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/" data-id="cl4mjnbfz00077kw4dayyfhyy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-概率论沉思录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%B2%89%E6%80%9D%E5%BD%95/" class="article-date">
  <time datetime="2021-09-11T08:11:08.520Z" itemprop="datePublished">2021-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="定量规则"><a href="#定量规则" class="headerlink" title="定量规则"></a>定量规则</h1><p>概率论不过是简化成计算的常识。<br> ——拉普拉斯，1819</p>
<p> 我们已经阐明了问题，该问题可以归结于一个直接的数学问题：</p>
<p>（1） 由实数代表概率的程度</p>
<p>（2） 与经验常识相符合</p>
<p>（3） 一致性</p>
<p>本章节试图根据上述问题完全推导出定量规则，这些规则有着长期、复杂、令人惊异的历史，总是充斥在所有科学方法论的课程中（参见最后章节）。</p>
<h2 id="2-1-乘积律"><a href="#2-1-乘积律" class="headerlink" title="2.1 乘积律"></a>2.1 乘积律</h2><p>首先寻找关于乘积$AB$概率的规则。特别的，首先找到$AB|C$。因为论证有些微妙，我们从几个不同的视角看待这个问题。<br>第一个角度，确定$AB$为真的过程可以被分成几个单独关于$A$和$B$的子问题。机器人可以</p>
<p>（1） 判断$B$是否为真；（$B|C$)</p>
<p>（2） 已经接受B为真，判断$A$是否为真。（$A|BC$)</p>
<p>或者等价于</p>
<p>（1） 判断$A$是否为真；（$A|C$)</p>
<p>（2） 已经接受A为真，判断$B$是否为真。（$B|AC$)</p>
<p>在每种情况下，我们都表示出每个步骤的合情程度。现在让我们用语言来描述第一个程序。为了使得$AB$成为一个真命题，$B$应当为真。因此首先要考虑$B|C$的概率。 此外，如果$B$为真，$A$也要为真，因此需要$A|BC$。</p>
<p>但如果$B$为假，$AB$当然也为假，无论$A$是否为真，因此被表达成$A|\overline{B}C$；如果机器人首先推导出$B$的情况，只有当$B$为真时，才需要考虑$A$的概率。如果机器人有了$B|C$和$A|BC$，就不需要$A|C$。类似地，$A|B$和$B|C$也不需要；无论$A$和$B$的概率是什么样的，当缺乏$C$的信息。例如，如果机器人不知道地球是圆的，当它学习了这一知识之后，在判断当今宇宙学的问题时，它不需要考虑它可能拥有的意见（即它需要考虑的额外可能性）。</p>
<p>as expressed by A|B C; if the robot reasons first about B, then the plausibility of A will be relevant only if B is true. Thus, if the robot has B|C and A|BC it will not need A|C. That<br>would tell it nothing about AB that it did not have already.<br>Similarly, A|B and B|A are not needed; whatever plausibility A or B might have in the absence of information C could not be relevant to judgments of a case in which the robot knows that C is true. For example, if the robot learns that the earth is round, then in judging questions about cosmology today, it does not need to take into account the opinions it might have (i.e. the extra possibilities that it would need to take into account) if it did not know that the earth is round.<br>Of course, since the logical product is commutative, AB = B A, we could interchange A<br>and B in the above statements; i.e. knowledge of A|C and B|AC would serve equally well<br>to determine AB|C = B A|C. That the robot must obtain the same value for AB|C from<br>either procedure is one of our conditions of consistency, desideratum (IIIa).<br>We can state this in a more definite form. (AB|C) will be some function of B|C and<br>A|BC:<br>(AB|C) = F[(B|C), (A|BC)]. (2.1)<br>Now, if the reasoning we went through here is not completely obvious, let us examine some<br>alternatives. We might suppose, for example, that<br>(AB|C) = F[(A|C), (B|C)] (2.2)<br>might be a permissible form. But we can show easily that no relation of this form could<br>satisfy our qualitative conditions of desideratum (II). Proposition A might be very plausible<br>given C, and B might be very plausible given C; but AB could still be very plausible or<br>very implausible.<br>For example, it is quite plausible that the next person you meet has blue eyes and also<br>quite plausible that this person’s hair is black; and it is reasonably plausible that both are<br>true. On the other hand it is quite plausible that the left eye is blue, and quite plausible that<br>the right eye is brown; but extremely implausible that both of those are true. We would have<br>no way of taking such influences into account if we tried to use a formula of this kind. Our<br>robot could not reason the way humans do, even qualitatively, with that kind of functional<br>relation.<br>But other possibilities occur to us. The method of trying out all possibilities – a kind of<br>‘proof by exhaustion’ – can be organized as follows. Introduce the real numbers<br>u = (AB|C), v = (A|C), w = (B|AC), x = (B|C), y = (A|BC). (2.3)<br>If u is to be expressed as a function of two or more of v, w, x, y, there are 11 possibilities.<br>You can write out each of them, and subject each one to various extreme conditions, as in<br>the brown and blue eyes (which was the abstract statement: A implies that B is false). Other<br>extreme conditions are A = B, A = C, C ⇒ A, etc. Carrying out this somewhat tedious</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%B2%89%E6%80%9D%E5%BD%95/" data-id="cl4mjnbft00037kw45w869a13" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-随机过程学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/14/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-08-14T01:20:53.561Z" itemprop="datePublished">2021-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-1-事件与概率"><a href="#1-1-事件与概率" class="headerlink" title="1.1 事件与概率"></a>1.1 事件与概率</h1><h2 id="样本空间与事件"><a href="#样本空间与事件" class="headerlink" title="样本空间与事件"></a>样本空间与事件</h2><p>事件：基本事件的集合<br>德摩根定理<br>古典概率<br>事件域<br>一维borel点集<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/33991971">borel点集的重要性</a><br>概率空间<br>条件概率乘积公式？<br>全概率公式<br>完备事件组<br>$\sigma-代数$其实是个集合系,它保证在这里头的集合,不管如何做交差并补,随便做可列次,结果都还在这个系里面.这对运算的良定义是很关键的.<br>随机变量的特征函数，引申阅读需要测度知识<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23686709">如何理解特征函数</a></p>
<p>不错的博客<br><a target="_blank" rel="noopener" href="http://sijichun.pro/">http://sijichun.pro/</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86155988">$\sigma-$代数的生成</a></p>
<p>测度论的典型方法<br><a target="_blank" rel="noopener" href="https://download.csdn.net/download/zwbell/1775871">测度论习题及答案</a></p>
<p>翻到第一页，似乎什么都知道，翻到第n页，似乎就很费劲，这是为什么呢</p>
<p>要对测度论的语言非常熟悉</p>
<p>$I_{A \cap{ B}}=A $</p>
<p>习题要不要做</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/14/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0/" data-id="cl4mjnbfy00067kw490kn75ma" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Proposal-of-Panpan" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/03/Proposal-of-Panpan/" class="article-date">
  <time datetime="2021-07-03T05:25:21.000Z" itemprop="datePublished">2021-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/03/Proposal-of-Panpan/">铂基纳米材料的制备及其在燃料电池方面的应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>燃料电池是继火力、水力及核能之后的第四种发电方式，其中质子交换膜燃料电池可以将贮藏在氢气和氧气中的化学能直接转化为电能，不受卡诺循环限制，具有高的能源转化效率、低污染、低振动、低噪音、安全、工作寿命长等优点，在提倡绿色低碳经济发展、实现碳达峰、和碳中和的背景下，非常具有替代传统内燃机的潜力，有着广阔的应用前景。然而质子交换膜燃料电池阴极缓慢的动力学限制了电池的整体性能。到目前为止，在所有可用的催化剂中，铂基催化剂展现出了最好的性能。但是Pt作为一种贵金属，储量非常有限，其高额的成本是目前燃料电池不能普遍商业化的重要原因之一。所以，在提高铂基纳米催化剂催化性能的同时降低铂的用量，具有很大研究价值和商业价值；此外，催化剂的长期耐久性也是一个重要的考虑因素。</p>
<p>在过去几年里，研究者们致力于降低贵金属铂的含量的同时提高催化剂的性能，为此开发出许多性能优异的催化剂，例如通过引入过渡金属制备二元或多元合金、通过配体效应增强或削弱反应物键能的合金催化剂、通过制备具有特殊形貌的材料等，在理论及实际应用上推动了燃料电池催化剂的研究进展。另外，通过多元醇法、浸渍法、微乳法、电化学沉积法、溶胶法等，可以可控地制备出不同形貌的高性能催化剂。本论文通过浸渍还原法以及多元醇法制备铂钴和铂镍合金催化剂，并探索材料制备条件对催化剂的形貌、活性及其稳定性的影响，从而进一步的改进催化剂的制备，提高其耐久性和活性。</p>
<h1 id="立题依据"><a href="#立题依据" class="headerlink" title="立题依据"></a>立题依据</h1><h2 id="1-研究意义（工程价值）"><a href="#1-研究意义（工程价值）" class="headerlink" title="1. 研究意义（工程价值）"></a>1. 研究意义（工程价值）</h2><p>质子交换膜燃料电池具有零排放、能量转化效率高、低噪音、便携方便、工作寿命长等优点，有很大潜力替代传统的内燃机，具有广阔的应用前景。但是质子交换膜燃料电池的阴极上发生的氧还原反应(ORR)的动力学十分缓慢，需要使用大量贵金属铂纳米催化剂作为电极催化剂来维持质子交换膜燃料电池的高效运转，这使得质子交换膜燃料电池的成本十分高昂，极大程度上限制了其普遍商业化应用。为此，降低质子交换膜燃料电池中贵金属铂的用量具有重要意义。在铂基催化剂研究领域，需要在降低铂用量的同时，还要提高铂基催化剂在氧还原反应中的质量活性以及稳定性。最近，有许多已报道的铂基催化剂拥有优良的质量活性，但其中绝大部分催化剂的稳定性还有较大的提升空间，这是由于报道中的催化剂虽然具有高质量活性，但其结构在电化学过程中不能够长期稳定存在，所以，研制兼具高质量活性和优良的稳定性的铂基催化剂极具挑战性。</p>
<p>许多报道表明，Pt基合金结构的催化剂PtM(M=Fe、Co、Ni、Cu、Pd、Au等)在减少Pt金属的载量的同时，又改变了表面Pt的电子结构，从而达到调控反应中间物种在表面的键能。由此，改善了催化剂的ORR催化活性。早期的研究包括金属合金化(二元合金PtM和三元合金PtMN)、制备金属间化合物 (双金属和三金属)、结构优化(核壳结构、多孔、空心、框架结构)等。通过将镍、铜、铁、钴、铬等3d过渡金属引入Pt金属的晶格中，调节材料的表面组成、晶格应变效应、表面配体效应、几何效应等电子效应以及优化活性位点，以提高贵金属催化剂的电催化活性。之前有研究表明，Pt金属对ORR过程中的活性中间物种的吸附较弱，而Co金属的表面反应性强，对活性物种的吸附过强。为此，将Co引入到Pt金属中，通过表面配体效应和晶格变形效应改变表面Pt的电子结构，使得活性物种的吸附强度适于催化反应进行。近期，有研究表明PtCo合金的氧还原催化活性比商业Pt/C催化剂要高许多倍，研究者们还探究了这种活性提高的原因。结果表明，配体效应、协同效应在电化学过程中发挥着重大作用。</p>
<p>本文将通过应用简单浸渍还原法和多元醇法合成Pt基纳米合金催化剂，将合成方法高效简单与合金结构的优异活性结合起来，旨在提高催化活性和稳定性，这对燃料电池催化剂的发展具有重要意义。</p>
<h2 id="2-国内外研究现状"><a href="#2-国内外研究现状" class="headerlink" title="2. 国内外研究现状"></a>2. 国内外研究现状</h2><p>目前，燃料电池催化剂的研究策略可以分为两大类：调控Pt基催化剂的电子结构和优化催化剂的活性位点。调控电子结构包括调控材料表面组成、表面结构、表面应力。调控材料的表面组成可以改变表面催化活性位点邻近的原子种类和数目，进而由于配体效应可以改变催化剂的d-带电子结构；同理，催化剂表面原子结构重排也会改变其电子结构，达到改善性能的效果；过去的研究也表明，当晶格扩展或收缩的时候会引起d-带原子重叠程度的改变，进而改变催化剂的活性。从这些角度看来，制备Pt基合金结构的催化剂可以达到上诉的效果。在合金催化剂的结构方面，制备核壳结构、以及二维或一维的催化剂能够大大地减少Pt的用量。Pt 基核壳结构催化剂M@Pt（M=Pd、Ru、Au、Ag、Fe、Cu、Co 等），还具有高的活性和稳定性。例如，Strasser等通过对PtCu催化剂颗粒电化学去合金，精确地调控Cu@Pt催化剂的Pt壳层的厚度，使得其原子层厚度大于4层，从而排除配体效应的影响，单独地探究应变效应对ORR催化性能的影响；Huang等通过乙二醇还原法制备的PtCo纳米线材料具有很高的质量活性以及大的电化学活性面积。虽然现在的核壳结构、二维或一维催化剂种类很多，性能也比商业Pt/C催化剂的高数十倍。然而，要将其商业化，还需要解决一些制备技术难题和成本问题。首先，廉价、高效的大规模核壳催化剂制备方法还未能实现；其次，部分经常使用的贵金属（Pd、Au 和Ir）内核虽然可以提升催化剂的性能和稳定性，但其仍具有较高的成本。</p>
<p>一般核壳结构中，Pt壳层较厚，而参与催化的Pt却只有表面的几层。为减少催化剂中Pt的用量，许多研究者开发出单原子层的核壳结构催化剂，其被认为是最有前景的商业化催化剂之一。此外，单层的Pt核壳结构催化剂，对于理解表面反应物种与催化剂的键能和催化活性之间的关系，发挥着重要作用。Adzic组通过制备IrM(M=Fe、Co、Ni、Cu)核@单层Pt的核壳结构，探究了表面单层Pt壳层的电子结构与ORR电催化活性之间的关系。其研究表明，催化性能优异的核壳结构的核芯应该给与Pt壳层足够的应力，使其d带中心相对于Fermi能级下移；二维或一维铂基催化剂的制备过程也较为复杂。目前，单原子层核壳结构、以及二维或一维结构催化剂的商业化还存在许多问题，难以规模化生产制备则是其中之一，后续的研究若能解决该问题，则燃料电池的成本将会被大幅度的减少。</p>
<p>此外，还可以通过表面去合金化、化学溶出或置换法制备核壳结构。首先制备出PtM合金，再通过电化学法溶解表面的非贵金属M或者通过金属偏析作用最终形成PtM@Pt核壳结构催化剂。Huang等合成了三元的PtNiCo催化剂。由于几何、表面和电子结构的改变，PtNiCo催化剂表现出优异的ORR和MOR催化性能。其ORR质量活性在0.90 V vs.RHE时为,4.20 A/mg，这比商业Pt/C催化剂高出22倍。</p>
<p>本文使用浸渍还原方法制备核壳结构合金催化剂，旨在提高催化剂的电化学活性和稳定性，探究出简单的制备方法，使纳米粒子的应变效应使之催化性能有所提高。</p>
<h2 id="3-主要参考文献及出处"><a href="#3-主要参考文献及出处" class="headerlink" title="3. 主要参考文献及出处"></a>3. 主要参考文献及出处</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/03/Proposal-of-Panpan/" data-id="cl4mjnbfr00017kw4gfqi52zh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-记录生活" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/21/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/" class="article-date">
  <time datetime="2021-06-21T04:55:21.000Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/21/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/">记录生活</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2021-06-30"><a href="#2021-06-30" class="headerlink" title="2021-06-30"></a>2021-06-30</h1><p>我有如此多工作去做，他们都是我自己要求的。然后我很少能够彻底完成工作。应当换一个方式，先不要想着完成什么阶段性目标，这样一旦放弃了，就不想再去做。我应当如此设定目标：每天写一点代码，学一学英语，看一看书，与人去交流一下，多出去散散步。不要追求阶段任务。</p>
<h1 id="2021-07-08"><a href="#2021-07-08" class="headerlink" title="2021-07-08"></a>2021-07-08</h1><p>我是一个缺乏自信的人，当我犯了一个错误后，我总会觉得自己不行，心里就会发懵，导致后续也不能正常的工作。为什么我会去做那些奇奇怪怪的东西，因为我在正常工作内不能做好，自信心不能得到支撑，只能通过做一些其他的东西，彰显自己，自欺欺人的说我不是不能干好，只是不愿意干。</p>
<p>结果和心态是复合的。当我们相信“结果肯定是好的”时候，我们对未来就会有积极的想象，这些积极的想象又能改善我们的情绪，积极的情绪能产生更强的动力，更强的动力又能导致更强的执行力，更强的执行力才能带来积极的结果。</p>
<p>当我认为自己搞砸了事情的时候，我对接下来的工作就有消极的想象，担心自己接下来不知道会在什么地方犯错，而消极的想象会导致自己从正常的工作状态偏移，导致犯错的可能性进一步加大，从而导致一个负面的螺旋。 然而犯错是无法避免的，我不能苛求自己不犯错误。如何面对错误？自己对自己负荆请罪，自我否定，这就是我过去的模式。无限自责，反而会因小失大，越错越多。</p>
<p>我还是不知道怎么做，当然不能苛求马上改变自己。也许我应该多锻炼身体，身体健康说不定能带来更加积极的心态。至少现在，我不能纠结于这个问题，苦闷一晚上，逃避于手机中，逃避于写日记中，正常做自己平时做的事情，不要再去想他了。</p>
<h1 id="2021-07-12"><a href="#2021-07-12" class="headerlink" title="2021-07-12"></a>2021-07-12</h1><p>人生是一场体验，我要将他变得无与伦比。</p>
<h1 id="2022-03-12"><a href="#2022-03-12" class="headerlink" title="2022-03-12"></a>2022-03-12</h1><p>我不能浪费自己的时间在奶头乐中。玩游戏不过是把这段时间抛弃掉，等待下一个阶段的到来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/21/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/" data-id="cl4mjnbfu00047kw4d165bpjx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TerrainDisplay" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/19/TerrainDisplay/" class="article-date">
  <time datetime="2021-06-19T15:39:24.000Z" itemprop="datePublished">2021-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/19/TerrainDisplay/">TerrainDisplay</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>CFIT(Controlled Flight Into Terrain，可控飞行撞地)是一种航空事故，在该类事故发生时，飞行员仍然正常控制着航空器，但是因为一些失误导致机组在毫无察觉时撞击地面、障碍物或者水面。CFIT发生的原因有很多，包括不利的气象条件（大雾、入云）、导航设备故障、ATC引导错误以及飞行员人为因素等。在地面迫近警告系统（GPWS）开发应用之前CFIT是民航飞行事故常见的类型，为此，民航开始在飞机上安装GPWS近地警告系统避免类似事故的发生，增加安全性。1974年，FAA开始对在美国空域飞行的航班上的GPWS进行强制安装要求，1979年，国际民航组织推荐使用者安装该设备。此后CFIT事故急剧减少。1985年后，CFIT事故每年仅发生1到2次，而强制要求安装前每年发生7到8次。全球几乎所有的商用喷气飞机均装备GPWS。</p>
<p>然而在通用航空器中，CFIT事故依然时有发生，特别是直升机。直升机的作业特点使得其通常在贴近地面活动，另外部分直升机并未装配有GPWS系统，特别是一些受到空间和载重限制的小型航空器，因此直升机仍然受到CFIT事故的威胁。根据NTSB的统计数据，CFIT在最常见的直升机事故类型中排在第13名，其中60%的CFIT事故是致命的。</p>
<p>针对这一问题，我试图开发一款手机软件，模仿增强型地面迫近警告系统的前视地形警戒功能（Look-ahead Terrain Alerting)，内建地形数据库，在飞行活动时，根据定位和地形数据为飞行员提供地形预警。</p>
<h1 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析"></a>系统分析</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>无需联网获取定位信息，包括经纬度、高度，并通过连续定位信息解算航迹角、地速、升降率</li>
<li>根据当前经纬度和航迹角，加载周围一定范围的地形数据</li>
<li>根据高度、地速、升降率进行地形预警</li>
<li>将地形数据转换成图片，包括等高线、高地形高亮显示等，能够显示、缩放；</li>
<li>提供地形数据下载，包括根据航线下载、范围下载、飞行实时下载。<h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h2></li>
<li>定位信息</li>
<li>地形加载</li>
<li>信息显示</li>
<li>地形下载</li>
</ol>
<h1 id="系统设计与实现"><a href="#系统设计与实现" class="headerlink" title="系统设计与实现"></a>系统设计与实现</h1><h2 id="（一）定位信息"><a href="#（一）定位信息" class="headerlink" title="（一）定位信息"></a>（一）定位信息</h2><p>定位信息分成两块，一个是真实定位，用于生产环境；另一个是虚拟定位，用于测试环境。</p>
<h3 id="（1）真实定位"><a href="#（1）真实定位" class="headerlink" title="（1）真实定位"></a><font size=4>（1）真实定位</font></h3><ol>
<li><font size=3>选择地位方法</font><br>可利用地图服务商（高德）的SDK定位或者原生定位。原生定位更方便，不用获取Key。<br>选择纯GPS定位，因为飞行时可能没有信号。AGPS定位,没有全频段搜星的过程，首次定位速度大大提高，但是需要联网，暂时不用。</li>
<li><p><font size=3>需要获得的数据</font><br>位置、高度、地速、空速、上升率，大气温度、修正高度量、修正速度量、CHX。</p>
</li>
<li><p>每隔$ Interval/5秒$更新定位；</p>
<h3 id="（2）模拟定位"><a href="#（2）模拟定位" class="headerlink" title="（2）模拟定位"></a><font size=4>（2）模拟定位</font></h3></li>
<li>给定一个初始的定位信息，并给定航向，升降率。</li>
<li>每隔$ Interval/5秒$计算出新的模拟定位信息；</li>
</ol>
<h2 id="（二）地形加载-DEMoperate"><a href="#（二）地形加载-DEMoperate" class="headerlink" title="（二）地形加载$DEMoperate$"></a>（二）地形加载$DEMoperate$</h2><h3 id="（1）数据源选择"><a href="#（1）数据源选择" class="headerlink" title="（1）数据源选择"></a>（1）数据源选择</h3><p>选择NASADEM作为数据源</p>
<h3 id="（2）实现流程"><a href="#（2）实现流程" class="headerlink" title="（2）实现流程"></a>（2）实现流程</h3><ol>
<li>输入参数：当前经纬度位置，半径$r$。</li>
<li>根据位置、航向和半径r解算出需要的数据范围，最开始的设计中，该范围大于$r$，后面会涉及到旋转，裁剪，需要保证半径r的外接矩形数据都存在。优化算法后，只需要得到半径$r$内的正方形的地形数据，因为只需要半径$r$的圆形范围的地形数据，旋转操作由$ImageDispose$完成。</li>
<li>取得涉及到的tiles，并存储到内存中，无需每次都读取，而是用更新；</li>
<li><p>将二进制流转换成short数组，并完成拼接；（Android10的权限问题）</p>
<p> 这里可以做出如下优化：<br> 由于直升机的位置不可能跑太远，因此下一次所需要的矩阵和当前矩阵有相当一部分时重合的。因此,这一部分无需重新赋值，而是把新增的加入，多余的删除。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将矩阵重新生成，确保左右相邻和上下相邻距离等长</span></span><br><span class="line"><span class="comment"> * 优化：新的矩阵要根据旧矩阵来坐标重映射</span></span><br><span class="line"><span class="comment"> * 重映射就是把一幅图像中某位置的像素放置到另一个图片指定位置的过程。为了完成映射过程，需要获得一些坐标重映射为非整数像素的坐标。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> R</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bottom_width</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SimpleMatrix <span class="title">DEMDataRemapOptimized</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先判断，如果没有旧矩阵，第一次运行或者，两个矩阵距离很远，没有重合范围。</span></span><br><span class="line">    <span class="comment">//则完全重新计算</span></span><br><span class="line">    <span class="comment">//有没有重合范围的判定：</span></span><br><span class="line">    distance_x = LatlngCalculate.getdistance();<span class="comment">//横向距离</span></span><br><span class="line">    distance_y = LatlngCalculate.getdistance();<span class="comment">//纵向距离</span></span><br><span class="line">    <span class="keyword">if</span>(mat1_old ==<span class="keyword">null</span> || (distance_x&gt;=r_old-<span class="number">0.1</span> &amp;&amp; distance_y&gt;=r_old-<span class="number">0.1</span>))&#123;<span class="comment">//之所以减去个0.1，因为此时重合范围很小，没意义</span></span><br><span class="line">        <span class="keyword">return</span> DEMDataRemapNotOptimized(SimpleMatrix mat,<span class="keyword">float</span> R, <span class="keyword">float</span> bottom_width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有很大重合范围的情况：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先看左边</span></span><br><span class="line">    <span class="comment">//1. 计算重映射后的旧矩阵mat_old左上角到未重映射的新矩阵mat_new_raw同一纬度的左边界点的距离&#123;@link d1&#125;</span></span><br><span class="line">    <span class="keyword">int</span> d1 = LatlngCalculate.getdistance();</span><br><span class="line">    <span class="comment">//2. 计算mat_new_raw左上角到mat_old上边界的高度&#123;@lin h&#125;</span></span><br><span class="line">    <span class="keyword">int</span> h = ;</span><br><span class="line">    <span class="comment">//3. 计算梯形mat_new_raw的左下角角度的tan值</span></span><br><span class="line">    <span class="keyword">double</span> tanTheta = (bottom_width*<span class="number">0.5</span>-R)/(<span class="number">2</span>*R);</span><br><span class="line">    <span class="comment">//4. 计算mat_new_raw左上角在mat_old上边界的铅锤点到mat_new_raw左边界的距离&#123;@lin d2&#125;</span></span><br><span class="line">    <span class="keyword">int</span> d2 = h/tanTheta;</span><br><span class="line">    <span class="comment">//5. 计算mat_old两点之间的距离&#123;@link du_fixed&#125;，这个距离是常数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">float</span> du_fixed = ;</span><br><span class="line">    <span class="keyword">if</span>(lng_left_new&gt;= lng_left_old)&#123;<span class="comment">//这种情况，左侧的数据多了，需要裁剪</span></span><br><span class="line">        <span class="comment">//6. 计算需要裁剪的列数</span></span><br><span class="line">        <span class="keyword">int</span> colnums_cut = Math.floor((d2+d1)/du_fixed);</span><br><span class="line">        <span class="comment">//7. 裁剪</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//左边的数据需要增加</span></span><br><span class="line">        <span class="comment">//6. 计算mat_new_raw在mat_old左上角所在纬度两点之间的距离&#123;@link du_special&#125;</span></span><br><span class="line">        <span class="keyword">float</span> du_special_leftTopCorner = ;</span><br><span class="line">        <span class="comment">//7. 计算mat_old左上角在mat_new_raw里面的横坐标（非整点）</span></span><br><span class="line">        <span class="keyword">float</span> x0 = d2/du_special_leftTopCorner;</span><br><span class="line">        <span class="comment">//8. 计算需要增加的列数</span></span><br><span class="line">        <span class="keyword">int</span> colnums_add = Math.ceil((d2-d1)/du_fixed);</span><br><span class="line">        <span class="comment">//9. 计算mat_old最上面一行在mat_new_raw的第？行（从0开始计数）</span></span><br><span class="line">        <span class="keyword">int</span> y0 = ?;</span><br><span class="line">        <span class="comment">//9. 计算mat_new_raw在mat_old第&#123;@link y&#125;所在纬度两点之间的距离&#123;@link du_special&#125;，这个距离随着纬度变化而变化，因此每一行都要进行计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; M;j++)&#123;<span class="comment">//M是mat_old的行/列数</span></span><br><span class="line">            <span class="keyword">int</span> y = j+y0;</span><br><span class="line">            <span class="keyword">float</span> du_special = ;</span><br><span class="line">            <span class="comment">//10. 先从最靠近mat_old左边界开始添加,依次求出需要增加点在mat_new_raw里面的横坐标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;= colnums_add;i++)&#123;</span><br><span class="line">                <span class="keyword">float</span> x = x0-(du_fixed/du_special)*i;</span><br><span class="line">                <span class="comment">//11. 计算该点的高程</span></span><br><span class="line">                <span class="keyword">float</span> height = calculate_Height_Numberic_X_point(mat_new_raw,y,x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*计算矩阵中横坐标为非整数的点的高程（纵坐标必须为整数点）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculate_Height_Numberic_X_point</span><span class="params">(SimpleMatrix mat,<span class="keyword">int</span> y, <span class="keyword">float</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_l = (<span class="keyword">int</span>)floor(x);<span class="comment">//j左侧的旧点</span></span><br><span class="line">    <span class="keyword">int</span> x_r = (<span class="keyword">int</span>)ceil(x);<span class="comment">//j右侧的旧点</span></span><br><span class="line">    <span class="keyword">double</span> z_l = mat.get(y,x_l);<span class="comment">//j左侧旧点的高度</span></span><br><span class="line">    <span class="keyword">double</span> z_r = mat.get(y,x_r);<span class="comment">//j右侧旧点的高度</span></span><br><span class="line">    <span class="keyword">double</span> z_i = z_l + (z_r-z_l)*(x-x_l);<span class="comment">//新点的高度,这个很难矢量化操作</span></span><br><span class="line">    <span class="keyword">return</span> z_i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SimpleMatrix <span class="title">DEMDataRemapOptimized</span><span class="params">(SimpleMatrix mat,<span class="keyword">float</span> R, <span class="keyword">float</span> bottom_width)</span></span>&#123;</span><br><span class="line">    Log.v(TAG,<span class="string">&quot;DEMDataRemapOptimized&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> numheight = mat.numRows();</span><br><span class="line">    <span class="keyword">int</span> numwidth = mat.numCols();</span><br><span class="line">    <span class="comment">//列数会多余行数，即N&gt;M</span></span><br><span class="line">    <span class="comment">//上下两点之间的距离始终是等长的，同一高度上左右点间隔是等长的，但是不同高度的左右点间隔是不等长的。</span></span><br><span class="line">    <span class="comment">// mat的顶端宽度和高度肯定不小于2R</span></span><br><span class="line">    <span class="comment">//坐标</span></span><br><span class="line">    <span class="keyword">int</span> N = numwidth;<span class="comment">//width</span></span><br><span class="line">    <span class="keyword">int</span> M = numheight;<span class="comment">//height</span></span><br><span class="line">    SimpleMatrix mat1 = <span class="keyword">new</span> SimpleMatrix(M,M);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第0行</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> j;</span><br><span class="line">    <span class="keyword">int</span> j_l,j_r;</span><br><span class="line">    <span class="keyword">double</span> z_r,z_l,z_i;<span class="comment">//z_i表示新点的高程，z_l为新点在原mat内左侧点的高程，z_r为右侧</span></span><br><span class="line">    <span class="comment">//梯形的左下角角度的tan值</span></span><br><span class="line">    <span class="keyword">double</span> tanTheta = (bottom_width*<span class="number">0.5</span>-R)/(<span class="number">2</span>*R);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span> ; y &lt; M; y++)<span class="comment">//行索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x0 = <span class="number">0</span>; x0 &lt; M; x0++)&#123;<span class="comment">//列索引</span></span><br><span class="line">            i = x0;</span><br><span class="line">            j = (y*tanTheta+i)/(M-<span class="number">1f</span>+<span class="number">2f</span>*y*tanTheta)*(N-<span class="number">1f</span>);<span class="comment">//新点的横坐标在旧坐标体系里面的位置</span></span><br><span class="line">            <span class="comment">//Log.d(TAG,String.format(&quot;j=%f&quot;,j));</span></span><br><span class="line">            z_i = calculate_Height_Numberic_X_point(mat,y,j);</span><br><span class="line">            mat1.set(y,i,z_i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> mat1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>坐标重映射。坐标重映射也可以减小重合部分的重复计算</li>
</ol>
<h3 id="（3）坐标重映射"><a href="#（3）坐标重映射" class="headerlink" title="（3）坐标重映射"></a>（3）坐标重映射</h3><p>由于在不同纬度，两个经度之间的距离不一样。低纬度地区，一经度距离更长。因此获取的地形数据矩阵，下侧的行，两点之间的距离长于上侧的行。在30°纬度和29°纬度，每1经度，距离相差3km。因此获取的矩阵实际上是个梯形，需要坐标重映射重新生成一个新的矩阵。<br>如果按照bottom的经度取点，那么同样的经度在top时，距离会短于2*R,因此只能按照top的经度取点。</p>
<p>一经度的距离小于一纬度的距离（只有在赤道上才相等），因此按照top生成的矩阵，密度也更高，$numCols(N))$同样也大于$numRows(M)$。</p>
<p>纬度的间隔为$\frac{2R}{M-1}$，经度的间隔为$\frac{2R}{N-1}$</p>
<p>$2R=M-1$第y行的宽度为$2R+2y\cdot tan(\theta) = N-1$</p>
<p>相对于旧坐标第0点，新坐标$i$的位置在$f=\frac{2R}{M-1}y\cdot tan(\theta)+2R\frac{i}{M-1}$<br>该位置用旧的坐标计算应该在<script type="math/tex">j = (N-1)\cdot\frac{f}{2R+2\frac{2R}{M-1}y\cdot tan(\theta)}</script></p>
<script type="math/tex; mode=display">j=(N-1)\cdot\frac{ytan(\theta)+i}{M-1+2ytan(\theta)}</script><p>近似成梯形</p>
<script type="math/tex; mode=display">\frac{z_i-z_l}{z_r-z_l}=\frac{j-j_l}{j_l-j_r}</script><script type="math/tex; mode=display">z_i = z_l+(z_r-z_l)(j-j_l)</script><ol>
<li>将该矩阵旋转，使得矩阵朝向和航迹角一致，旋转时需要重新坐标重映射。</li>
<li>裁剪矩阵，仅仅保留半径$rkm$范围内的数据<br>不做5、6，仅仅坐标重映射后就显示图片，旋转工作由系统API完成，速度更快<br>找前方用其他数学方法</li>
</ol>
<h2 id="信息显示"><a href="#信息显示" class="headerlink" title="信息显示"></a>信息显示</h2><p>输入参数：半径$rkm$内的地形数据、速度、高度curAltitude、升降率<br>通过颜色分层：</p>
<ol>
<li>深红色，curAltitude+[+600,+∞)。考虑到高程数据的误差和定位误差</li>
<li>淡红色 curAltitude+[+300,600)</li>
<li>土黄色   curAltitude+[-200,+300)</li>
<li>深绿色 curAltitude+[-300,-200)</li>
<li>浅绿色 curAltitude+[-600,-300)</li>
<li>黑色 curAltitude+(-∞,-600]</li>
<li>洋红色 无数据<br>altitude_layers = {+600,+300,-200,-300,-600}<br>color_layers = {深红色,淡红色,土黄色,深绿色,浅绿色,黑色,洋红色}<br>某个点处于，深红色区域，那么周围一定范围内的点都应是红色区域，否则单个像素可能不可见</li>
</ol>
<p>图片叠加</p>
<p>指示范围（km）</p>
<p>1、2、3、4、5</p>
<p>2、4、6、8、10</p>
<p>3、6、9、12、15</p>
<p>4、8、12、16、20</p>
<p>5、10、15、20、25<br>航迹指示 小刻度5°、大刻度10°</p>
<p>地形警告:<br>前方，半径x公里内出现危险地形,这个简单，设置颜色时就可以做，先不管</p>
<p>模仿汽车的告警<br>圆弧，红色，黄色，绿色，航向±30°，告警</p>
<p>实时解算<br>自己写定时方法，好控制</p>
<p>下载功能，侧边栏切换，设置功能，开关功能（后台运行），语音报警<br>下载功能：解压<br>设置：<br>经纬度显示格式（°分秒）<br>地图范围半径（不小于1km）<br>地形显示刷新间隔（不小于1秒）单位ms<br>地形数据存储路径</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>terrainWarner和FlightPara 单例模式<br>控制定位service开启<br>周期性定位和地形检查在service内完成，数据如何传递到页面</p>
<p>链接到百度网盘下载</p>
<p>高大地物记录</p>
<p>地理围栏，获取最高标高，标记高大障碍物，线状，点状，面状</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/magicboy110/archive/2010/12/12/1903927.html">AGPS定位原理浅析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351074783">使用Python处理SRTM(.hgt)文件</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://librenepal.com/article/reading-srtm-data-with-python/">Hgt文件解析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/icydengyw/p/12318522.html">高程数据汇总</a></p>
</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fb89ab396bf8">用Android原生SDK中的api定位</a></li>
<li><p><a href="E:\MyProgram\Python\HgtRead">Hgt读取，python代码示例</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://ejml.org/javadoc/org/ejml/simple/SimpleMatrix.html">SimpleMatrix文档</a></p>
</li>
<li><p>DEM数据源:<a target="_blank" rel="noopener" href="http://www.gscloud.cn/sources/index?pid=302&amp;ptitle=DEM%20%E6%95%B0%E5%AD%97%E9%AB%98%E7%A8%8B%E6%95%B0%E6%8D%AE&amp;rootid=1&quot;地理空间云&quot;">地理空间云</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43936250/article/details/105372699">python大端模式和小端模式</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366961302">JAVA中的IO流（输入输出流）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuyongdun/p/9780907.html">int型与byte型数组的转换</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xmc281141947/article/details/74740061">Java中&amp;0xFF是什么意思？计算机的原码、补码和反码</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/56a717173227">矩阵旋转变换公式</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lweiyue/article/details/91490460">绘制等高线图的算法</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bewithme/article/details/86538852">DL4J中文文档/ND4J/概述</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_41938770/article/details/100054771">配置NavigationView</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://e4ftl01.cr.usgs.gov/MEASURES/NASADEM_HGT.001/2000.02.11/NASADEM_HGT_n28e104.1.jpg">NASADEM数据源</a></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Location location = locationManager.getLastKnownLocation(locationProvider);</span><br><span class="line"><span class="comment">// 权限问题：需要添加地理位置权限</span></span><br></pre></td></tr></table></figure>
<p>匿名内部类：观察者模式</p>
</li>
</ol>
<p>如何阅读别人的代码</p>
<pre><code>地形数据生成时间 386 ms
</code></pre><p>I/test: 绘图以及产生告警信息总时间 420 ms</p>
<p>一、优化<br>1.重映射<br>opencv 投影变换<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/aaron1996123456/article/details/100898850">https://blog.csdn.net/aaron1996123456/article/details/100898850</a><br>2.颜色矩阵</p>
<p>新方案：<br>删除地形数据矩阵坐标重映射<br>而是将高度差矩阵投影变换成梯形，然后选择其中的内切正方形，再选择圆形，需要opencv<br>警告信息遍历？</p>
<p>opencv:<a target="_blank" rel="noopener" href="https://blog.csdn.net/matt45m/article/details/121853230">https://blog.csdn.net/matt45m/article/details/121853230</a></p>
<p>android jni:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97691316">https://zhuanlan.zhihu.com/p/97691316</a></p>
<p>二、告警信息</p>
<p>三、下载</p>
<p>四、山区模式</p>
<p>五、UI优化</p>
<p>正前方或者航线上，左右宽度为2km，长度20km的最高高程图，根据当前位置，v，Vy解算绿区、黄区和红区,已经安全通过需要的Vy<br>区间范围[-5,20]<br>白色预计曲线</p>
<p>实现图表</p>
<p>MPAndroidChart实现折线图不同区间范围的折线不同的颜色[<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuf0812/article/details/96999692">https://blog.csdn.net/yuf0812/article/details/96999692</a>]<br>Android开发：MPAndroidChart的配置和使用[<a target="_blank" rel="noopener" href="https://blog.csdn.net/CV_Jason/article/details/80494426">https://blog.csdn.net/CV_Jason/article/details/80494426</a>]</p>
<p>前方左右45°，半径20km的扇形范围内的最高点，相对方位</p>
<p>输入航线，永久保存，需要的tiles，判断是否有缺失</p>
<p>查找baidunetdisk文件夹下所有名字符合的压缩包，没有解压过的解压</p>
<p>利用unity3d实现3d地形,山区模式</p>
<p>障碍物记录，点，线，面</p>
<p>unity3d:使用九宫格的方式加载动态加载资源[<a target="_blank" rel="noopener" href="https://blog.csdn.net/J_JKHAN/article/details/103048432">https://blog.csdn.net/J_JKHAN/article/details/103048432</a>]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/19/TerrainDisplay/" data-id="cl4mjnbfs00027kw4b6rudldm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-统计理论学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/06/19/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-06-19T15:39:24.000Z" itemprop="datePublished">2021-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/06/19/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/">统计理论学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这么一个问题：<br>{x1,x2,…,xn}<br>x_i包含开收高低量<br>判断最高点<br>输入第一个x1</p>
<p>隐马尔可夫模型</p>
<p>首先解决 模型参数学习问题<br>其次预测问题，也称为解码问题</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41923961/article/details/82750687">HMM隐马尔可夫模型详解</a></p>
<p>每一列的均值和方差均不一样</p>
<p>hmm组成<br>一般将一个隐马尔可夫模型记为：$\lambda = [\Pi,A,B]$</p>
<p>需要确定以下三方面内容（三要素）：</p>
<p>初始状态概率$\Pi$：模型在初始时刻各状态出现的概率，记为$\Pi=\{\pi_1,\pi_2,\pi_3\}$，$\pi_1$表示模型的初始状态为$\bold{涨}$的概率.</p>
<p>状态转移概率$A$: 模型在各个状态间转换的概率，通常记为矩阵 $A[a_{ij}]$，其中$a_{ij}$表示在任意时刻 t，若状态为 Si，则在下一时刻状态为 Sj 的概率.</p>
<p>输出观测概率 B: 模型根据当前状态获得各个观测值的概率通常记为矩阵 B=[[公式]]。其中，[公式]表示在任意时刻 t，若状态为[公式]，则观测值[公式]被获取的概率.</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39912633">卡尔曼滤波</a></p>
<p>观测序列是连续的，状态层是离散的，并且，随着t的不同，转移概率会发生变化</p>
<p>$T=[0,240)$<br>对于时刻$t\in T$，价格服从正太分布$N(\mu_{pt},{\sigma}^2_{pt})$,成交量服从正态分布$N(\mu_{vt},{\sigma}^2_{vt})$,两者联合概率分布。（先不考虑成交量）<br>先变换成标准正态分布<br>状态层包含两个。</p>
<p>转换成数学问题描述</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85236423">EM算法原理及推导</a></p>
<p>现在包含m个样本，每个样本形如$\{(p_i,v_i,y_i)，i=\{1,2,…,n\}\}$,$p_i,v_i$独立同分布</p>
<p>用$x_i$表示$(p_i,v_i)$</p>
<p>求$P(y_i|x_1,x_2,…,x_i)$</p>
<p>$P(x_1,x_2,…,x_i)\cdot P(y_i|x_1,x_2,…,x_i)=P(y_i,x_1,x_2,…,x_i)$</p>
<p>$P(x_i)$不具备齐次马尔可夫性质<br>引入隐变量$Z$</p>
<p>$P(x_i)=$仅仅取决于$z_i$</p>
<p>$P(x_1,x_2,…,x_i)=\sum_z P(x_1,x_2,…,x_i|z_1,z_2,…,z_i)P(z_1,z_2,…,z_i)$<br>$=P(z_1)\Pi_{c=2}^i P(z_c|z_{c-1})\Pi_{c=1}^i P(x_c|z_{c})$</p>
<p>应当是这么一个结构：<br>$y_i$依赖于$z_i$，$z_i$依赖于$z_{i-1}$和$x_i$，这么$P(y_i|x_1,x_2,…,x_i)$就不能去掉任何一个$x_i$</p>
<p>$P(y_i|x_1,x_2,…,x_i) = \underset  {z_i\in Z}{\sum} P(y_i|z_i)$</p>
<p>$Z_i$有$a$个状态，$Y_i$有$b$个状态，用一个$a\times b$的矩阵描述<br>$x_i$有$c$个状态，$Z_i$的任意取值有一个$a\times c$的矩阵描述，那么$Z_i$有一个$a\times c\times a$的方阵描述</p>
<p>由于$X_i$同分布，$Z_i$同分布？</p>
<p>$P(z_i)$</p>
<p>无监督聚类</p>
<p>两种方法<br>首先在正收益率内聚类，然后在完整测试集合内检验</p>
<p>在完整训练集合内聚类，挑选最好的，完整测试集合内检验</p>
<p>两种聚类均不可用</p>
<h1 id="描述问题："><a href="#描述问题：" class="headerlink" title="描述问题："></a>描述问题：</h1><p>现有6万个数据$\{x,y\}$<br>$x$为N维向量，$y为$标量，范围从$[-10,10]$。<br>$x$的每一个维度和$y$都呈正太分布<br>现在希望得出一个模型，将$x$分成正样本和负样本。目标：正样本集对应的$y$的平均值最大，并且正样本需占整体的5%以上，并且模型足够简单（泛化能力强）。</p>
<h1 id="我自己想到的方法"><a href="#我自己想到的方法" class="headerlink" title="我自己想到的方法"></a>我自己想到的方法</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>训练出一个神经网络，将估计值较高的数据分出来即可。但是实际上，度量空间内距离，任意一个小邻域内的$\{x^{(1)},x^{(2)},…,x^{(i)}\}$对应的$\{y^{(1)},y^{(2)},…,y^{(i)}\}$整体不会如同$x$一样集中，而是同样在$[-10,10]$内呈现正太分布，只是统计特征（均值，方差等）不同于总体的分布。</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>将$x$分段，比如当$x$的维度$N=2$时，且每一个维度取值在[0,5)以内，每一个维度等分成5分，$x$整体分成一个$5\times 5$的矩阵$A$,$A_{ij}$表示该部分的$x=(x_1,x_2)$，$x_1\in [i,i+1),x_j\in [j,j+1)$，总共有25份，每一份对应的y的统计特征直接求出来，然后找到最优的一部分即可。</p>
<p>但是如果$x$的维度非常高时，方法2就无法使用。</p>
<h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h2><p>这个方法是我目前正在使用的。</p>
<p>我选取了（自认为最重要的）3个维度，执行方法2。</p>
<p>但是这样就忽略其他所有维度的数据。</p>
<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>今天看了一些p Quant的介绍，我想去学习更加高深的数学工具。困难：周期长，难度高，中途需要找到正反馈点，否则无法坚持。许多内容都是用在期权定价等问题上的，实际上我用不到，如何和我的量化交易结合起来将是一个问题。<br>包含内容：随机过程、鞅论、泛函分析、测度论、PDE等。<br>设置一个合理的学习路径，每学一点内容都能起到实际作用，至少能够给我带来新的视角。</p>
<p>我想解决的问题是：minute级别的交易策略</p>
<p>出现过涨停，未来n天内，价格回踩至十日线<br>未来m天卖出</p>
<script type="math/tex; mode=display">F(x) = \sum F_i(x)\cdot p_i</script><p>分成N组，属于第n组的概率是多少</p>
<script type="math/tex; mode=display">P(x\in A_i) = \frac{f_i(x)\cdot p_i}{f(x)}</script><p>其中</p>
<script type="math/tex; mode=display">f(x) =  \sum f_i(x)\cdot p_i</script><p>$f_i(x)$为第n组的概率密度函数</p>
<p>卡方分布<br>截断正太分布<br>参数估计<br>不需要具体的分布形式</p>
<p>将所有数据分成N组，划分依据是收益率<br>| 收益率范围 | 组别 | para |   |   |<br>|——————|———|———|—-|—-|<br>| -10%~-9%   | 1    |  $y_i$    |   |   |<br>|            |      |      |   |   |<br>|            |      |      |   |   |<br>求出在第n组的概率，在该组参数为（如果是正太分布，参数为收益率为$y_i$，方差为$\sigma_{y_i}$，如果是其他形式的分布，则需要其他参数）<br>现在我们假设是正太分布。</p>
<p>那么该样本的期望收益为$\sum P(x\in A_i)\cdot y_i$,收益方差为？</p>
<p>各个组别的平均收益率为$\bold{c}$,为常数</p>
<p>所有数据总体呈现正太分布，参数为$\mu,\sigma$</p>
<p>任何一个样本处在总体的位置为$x=\mu+p$，该点的概率密度为$f(x)$，其在各个组别的概率向量为$\bold{x}$（直接拟合，不假设分布做参数估计，也不弄成矩阵），那么该点不考虑仓位系数时期望收益率为$\bold{c}\cdot \bold{x^T}$,仓位系数为$r(x)$。</p>
<p>期望$E(X)=\int_{-10}^{10} {r(x)\cdot \bold{c}\cdot \bold{x^T}\cdot f(x)} \,{\rm d}x$</p>
<p>方差$D(X)=E(X^2)-E(X)^2$</p>
<p>$max E(X)$</p>
<p>$min D(X)$</p>
<p>$r(x)$的其他约束，最大值为1，假设每天最大仓位买入可以买入Q分，每天符合策略的票有$b_i,b_2,…,b_j$，累计起来期望值要尽可能接近Q，且超过时按照Q计算</p>
<p>$\sum{r(b(i))}&lt;=Q$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/19/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/" data-id="cl4mjnbfv00057kw41fin950p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/20/test/">test</a>
          </li>
        
          <li>
            <a href="/2022/06/20/hzw%E5%9C%A8%E5%AE%B6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%89%E6%8E%92/">HZW在家学习的安排</a>
          </li>
        
          <li>
            <a href="/2021/10/09/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/09/11/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%B2%89%E6%80%9D%E5%BD%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/14/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
</body>
</html>